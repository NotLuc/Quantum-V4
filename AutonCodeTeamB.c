/*#pragma config(Motor,  port2,           FrontLeft,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           FourBar,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           BackLeft,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           Flipper,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           Intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           BackRight,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           Launcher,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           FrontRight,    tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code generated by Luke                                                             *///
void driveForward(int x, int power){
	int tickCount = (x*180)/(3.1415926*2);
	SensorValue[leftDriveEnc]=0;
	SensorValue[rightDriveEnc]=0;

	while(SensorValue[leftDriveEnc]>-tickCount||SensorValue[rightDriveEnc]<tickCount){
		motor[FrontLeft]=motor[BackLeft]=power;
		motor[FrontRight]=motor[BackRight]-power;
	}
	motor[FrontLeft]=motor[BackLeft]=0;
	motor[FrontRight]=motor[BackRight]=0;
}
void driveBackwards(int x, int power){
	int tickCount = (x*180)/(3.1415926*2);
	SensorValue[leftDriveEnc]=0;
	SensorValue[rightDriveEnc]=0;

	while(SensorValue[leftDriveEnc]<tickCount||SensorValue[rightDriveEnc]>-tickCount){
		motor[FrontLeft]=motor[BackLeft]=-power;
		motor[FrontRight]=motor[BackRight]=power;
	}
	motor[FrontLeft]=motor[BackLeft]=0;
	motor[FrontRight]=motor[BackRight]=0;
}
task auton()
{
motor[FrontLeft]=motor[BackLeft]=0; //This just makes sure that nothing is running at the start
motor[FrontRight]=motor[BackRight]=0;

if(SensorValue[redAuto]==1){ //start RED auton
driveForward(46, 80); //First number is how far forward (Should be in inches...) Second Number is power!
driveBackwards(65, 80); //First number is how far forward (Should be in inches...) Second Number is power!
motor[FrontLeft]=motor[BackLeft]=-80; //Turn power
motor[FrontRight]=motor[BackRight]=-80; //Turn power

wait1Msec(530); //Turn time (ms)
//motor[FourBar]=15; //Ignore for now
motor[FrontLeft]=motor[BackLeft]=0; //Resets turn power to zero
motor[FrontRight]=motor[BackRight]=0; //Resets turn power to zero
driveBackwards(45, 80); //First number is how far forward (Should be in inches...) Second Number is power!
motor[FrontLeft]=motor[BackLeft]=0; //Stops driving
motor[FrontRight]=motor[BackRight]=0; //Stops driving
//motor[FourBar]=0;
wait1Msec(10000); //Waits for end
}
if(SensorValue[blueAuto]==1){ //Start BLUE auton
	driveForward(44, 80); //First number is how far forward (Should be in inches...) Second Number is power!
driveBackwards(64, 80);//First number is how far forward (Should be in inches...) Second Number is power!
motor[FrontLeft]=motor[BackLeft]=80; //Turn Power
motor[FrontRight]=motor[BackRight]=80; //Turn Power
//motor[FourBar]=70; // Ignore for now
wait1Msec(555); //Turn Time (ms)
//motor[FourBar]=15;
motor[FrontLeft]=motor[BackLeft]=0; //Resets Turn Power
motor[FrontRight]=motor[BackRight]=0; //Resets Turn Power
driveBackwards(32, 80); //First number is how far forward (Should be in inches...) Second Number is power!
wait1Msec(10000); //Waits until end
}
if(SensorValue[blueAuto]==0&&SensorValue[redAuto]==0){
	int time=nSysTime;
while(nSysTime>time+15000){
motor[FrontLeft]=motor[BackLeft]=0;
motor[FrontRight]=motor[BackRight]=0;
}
}


}
